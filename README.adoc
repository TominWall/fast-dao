= spring-db-template

=== Java ORM框架,大幅度提高开发效率,减少编码量
=== 作者: 张亚伟
=== QQ群: 554127796
=== GitHub: https://github.com/kaixinzyw/fast-db-template
=== 码云: https://gitee.com/fast-product/fast-db-template



== 功能简介
[source,text]
----
1. 极·简化数据库操作，大幅度提高编码效率,此框架核心价值所在,上手难度非常低;
    例-分页查询: PageInfo<Demo> page = DemoTemplate..create().dao().findPage(1, 10);
    例-新增数据: Boolean success = DemoTemplate.create().dao().insert(demo);
    例-更新数据: Integer updateCount = DemoTemplate.create().id(1).dao().update(demo);
    例-删除数据: Integer delCount = DemoTemplate.create().id(1).dao().delete();

2. 自动对<创建时间 | 更新时间 | 主键 | 逻辑删除>进行设置;

3. 支持3种数据缓存<本地缓存，Redis缓存，本地和Redis结合缓存>,支持缓存的自动刷新<更新,删除,新增>后会自动刷新缓存的数据;

4. 逻辑删除保护,对逻辑删除标记的数据在更新,查询等操作时候进行过滤;

5. SQL自检,对每一条SQL执行进行日志输出<可设置开启或关闭>,自动拼接SQL语句占位条件<复制即用>,并输出SQL执行效率,执行结果;
    例:
    com.db.test.pojo.UserTest: SELECT -> user_test: SQL执行报告↓
    SELECT `id` as id, `name` as name
    FROM user_test
    WHERE (`deleted` = false)
    AND (`name` = '张三')
    ORDER BY `age` asc  limit 1 ;
    本次执行耗时:3毫秒
    执行结果:
    [{"id":17333,"name":"张三"}]

6. 快速数据源更换,可以对任意一次操作进行数据源更换,方便快捷;

7. 支持自定义SQL,自动进行类和表之间的映射;

8. 丰富的模板文件生成器设置,满足各种场景的需求

9. 可按需要对框架扩展<任意数据库,任意框架>的快速操作实现<本框架自身实现了对JDBC和 MyBatis的MySql数据库操作扩展实现,可任意选择使用哪一种>;

10. 完美兼容其他ORM框架,可以搭配任意ORM框架一同使用<如:MyBatis>;

----
=== 1. 快速开始
==== 1.1 安装
[source,text]
----
    本项目使用JDK1.8,依赖SpringBoot,使用Maven
    <dependency>
        <groupId>com.github.kaixinzyw</groupId>
        <artifactId>fast-db-template</artifactId>
        <version>3.0.1</version>
    </dependency>
----

==== 1.2 框架配置
[source,text]
----
/**
 * 配置创建
 * 参数1: 可选值 1:SpringJDBCMySqlImpl.class:使用SpringJDBC实现, 2:FastMyBatisImpl.class: 使用MyBatis实现
 * 参数2: 框架操作的主键字段名称
 * 参数3: 框架操作的主键类型,目前可选32位UUID或自增AUTO
 */
AutomaticParameterSetting setting = new AutomaticParameterSetting(SpringJDBCMySqlImpl.class, "id", PrimaryKeyType.AUTO);

/**
 * 字段驼峰转换 例 user_name = userName
 */
setting.openToCamelCase();

/**
 * 开启SQL执行日志打印,INFO级别,自动使用项目使用的日志框架
 * 参数1: 是否打印SQL日志
 * 参数2: 是否打印SQL执行结果
 */
setting.openSqlPrint(true, true);

/**
 * 开启自动设置创建时间
 * 参数1: 需要设置创建时间的字段名
 */
setting.openAutoSetCreateTime("createTime");

/**
 * 开启自动设置更新时间
 * 参数1: 需要设置更新时间的字段名
 */
setting.openAutoSetUpdateTime("updateTime");

/**
 * 开启逻辑删除功能
 * 参数1:  逻辑删除字段名
 * 参数2:  逻辑删除标记默认值
 */
setting.openLogicDelete("deleted", true);

/**
 * 开启缓存功能
 * 参数1:  默认缓存时间
 * 参数2:  默认缓存时间类型
 */
setting.openCache(10L, TimeUnit.SECONDS);
----

==== 1.3 模板文件生成
[source,text]
----
FileCreateConfig config = new FileCreateConfig();

//数据库连接
config.setDBInfo("jdbc:mysql://127.0.0.1:3306/dome?useUnicode=true&characterEncoding=utf-8","root","123456","com.mysql.cj.jdbc.Driver");

//文件生成的包路径
config.setBasePackage("com.db.test");

//需要生成的文件类型 (可选值Base<生成Pojo类,Pojo查询模板,Pojo字段集>,Service<Service接口>,ServiceImpl<Service实现类>,Dto<Dto对象>,Dao<Dao对象>, All<上述所有文件>)
config.setNeedModules(FileCreateConfig.CodeCreateModule.All);

//是否生成表前缀
config.setPrefix(false,false,null);

//是否使用lombok插件
config.setUseLombok(true);

//是否下划线转大小写,默认true
config.setUnderline2CamelStr(true);

//是否覆盖原文件,默认false
config.setReplaceFile(false);

//多模块项目指定模块生成
config.setChildModuleName("service");

//需要生成的表名 (可选值,具体表名或all)
config.setCreateTables("user_test");

//生成代码
TableFileCreateUtils.create(config);

模板文件生成后,会对数据库中表创建相对应的操作模板
例: 数据库中的demo表进行模板文件生成后
--两种模板创建方式
    1.创建无初始化条件模板
    DemoTemplate template = DemoTemplate.create();
    2.创建有初始化条件模板,参数中值不为null的属性会作为AND条件
    DemoTemplate template = DemoTemplate.create(对象);

--模板文件中对应数据库每列都有相对应的字段操作
    1.无初始化参数字段操作
    template.字段名();
    2.有初始化参数的字段操作,传入的参数如果不为null会作为AND条件
    template.字段名(参数);

----

=== 2. 使用说明

==== 2.1 条件设置

DemoTemplate template = DemoTemplate.create();
|===
|功能 |方法 |说明

|相等条件设置
|template.字段名().valEqual(参数)
|指定字段值等于所传参数

|大于条件设置
|template.字段名().greater(参数)
|指定字段值大于所传参数

|大于等于条件设置
|template.字段名().greaterOrEqual(参数)
|指定字段值大于等于所传参数

|小于条件设置
|template.字段名().less(参数)
|指定字段值小于所传参数

|小于等于条件设置
|template.字段名().lessOrEqual(参数)
|指定字段值小于等于所传参数

|模糊匹配条件设置
|template.字段名().like(参数) +
template.字段名().likeLeft(参数) +
template.字段名().likeRight(参数)
|指定字段值符合模糊匹配条件

|范围条件设置
|template.字段名().between(min, max)
|指定字段值范围条件 +
例: 条件为年龄在20-30之间 +
template.age().between(20, 30)

|IN条件设置
|template.字段名().in("参数1","参数2"...) +
template.字段名().in(List)
|指定字段值包含所传参数

|IsNull条件设置
|template.字段名().isNull()
|指定字段值条件为null

|NotNull条件设置
|template.字段名().notNull()
|指定字段值条件不为null

|排序设置-升序
|template.字段名().orderByAsc()
|查询操作时进行排序-升序

|排序设置-降序
|template.字段名().orderByDesc()
|查询操作时进行排序-降序

|对象条件设置
|template.equalPojo(对象)
|对象中不为null属性会作为AND条件

|指定字段查询设置
|template.字段名().showField()
|查询操作时只查询指定字段,可设置多个

|过滤字段查询设置
|template.字段名().hideField()
|查询操作时不查询指定字段,可设置多个

|字段去重复设置
|template.字段名().distinctField();
|查询操作时指定字段去重

|自定义SQL条件设置
|template.andSql(SQL语句,参数) +
template.orSql(SQL语句,参数)
|会在WHERE后拼接自定义SQL语句 +
如果有参数需要使用#{参数名}进行占位 +
在参数值MAP集合put(参数名,参数值)

|关闭逻辑删除保护
|template.closeLogicDeleteProtect()
|会对本次执行进行逻辑删除保护关闭 +
关闭后所有操作会影响到被逻辑删除标记的数据

|OR条件设置
|template.字段名().or()
|指定字段OR条件设置 +
例: 条件为姓名等于张三或为null +
template.userName().valEqual("张三").or().isNull()
|===


==== 2.2 Dao执行器
[source,text]
----
Dao执行器调用:
    1.模板直接调用
    FastDao<Demo> dao = DemoTemplate.create().dao();
    2.字段条件操作时调用
    FastDao<Demo> dao = DemoTemplate.create().字段名().isNull().dao();
    例:如果单字段查询可以直接快速得到结果
    List<Demo> list = DemoTemplate.create().userName().isNull().dao().findAll();
----
执行器方法:
|===
|方法名 |说明

|Boolean insert(Pojo pojo)
|新增数据,并对设置的主键字段进行赋值

|Pojo findOne()
|通过查询条件查询一条数据

|List<Pojo> findAll()
|通过查询条件查询所符合要求的所有数据

|Integer findCount()
|通过查询条件查询所符合要求的数据数量

|PageInfo<Pojo> findPage(int pageNum, int pageSize)
|通过查询条件查询所符合要求的数据,并进行分页

|Integer update(Pojo pojo)
|通过条件更新数据, 参数为空则的字段不会进行更新

|Integer updateOverwrite(Pojo pojo)
|通过条件更新数据,参数为空则的字段也会进行更新

|Integer delete()
|对符合条件的数据进行逻辑删除标记 (本操作会自动将数据删除标记修改,并会对更新时间进行自动赋值)

|Integer deleteDisk()
|通过条件物理删除 (本操作会进行物理删除,请谨慎操作)

|===

==== 2.3 自定义SQL
[source,text]
----
多表等复杂SQL操作,可以使用自定义SQL执行器实现,框架会自动进行对象和表进行映射

FastCustomSqlDao<操作类> dao = FastCustomSqlDao.create(操作类, SQL语句, 参数)

例:
String sql = "SELECT u2.`name` as u2Name, u1.`name` as u1Name " +
             "FROM user_test2 u2 LEFT JOIN user_test u1 " +
             "WHERE u2.`AND u1.id = u2.user_test_id " +
             "AND u2.name = #{u2Name}";

Map<String, Object> params = new HashMap<>();
params.put("u2Name", "张三");

List<UserTest2Dto> all = FastCustomSqlDao.create(UserTest2Dto.class, sql, params).findAll();
----

==== 2.4 缓存使用
[source,text]
----
开启缓存功能后,可以操作类上添加注解的方式使用三种不同的缓存使用
/**
 * Redis缓存,当开启缓存并操作对象配置此注解时,会将查询到的数据缓存到redis中
 * 当进行使用此框架模板进行操作新增,更新,删除操作时,会自动刷新Redis缓存中的数据
 * 此实现使用了StringRedisTemplate
 * 默认参数为框架设置的缓存时间和类型
 * 缓存可选参数
 * FastRedisCache(Long 秒) 如@FastRedisCache(60L) 缓存60秒
 * FastRedisCache(cacheTime = 时间,cacheTimeType = TimeUnit) 如@FastRedisCache(cacheTime =1L,cacheTimeType = TimeUnit.HOURS) 缓存1小时
 */
1: @FastRedisCache

/**
 * Redis和本地内存结合的缓存,在特殊场景使用,数据库中需要实时进行集群同步,数据量大并取用频繁,并且数据修改不频繁的场景,如商品的品牌或类目信息
 * Redis只会存储版本号,本地存储具体数据内容
 * 当开启缓存并操作对象配置此注解时,会将查询到的数据缓存到本地中,同时在Redis中获取数据版本号
 * 当进行使用此框架模板进行操作新增,更新,删除操作时,会自动刷新Redis缓存中的数据数据版本号
 * 此方法使用了RedisConnectionFactory
 * 默认参数为框架设置的缓存时间和类型
 * 缓存可选参数
 * FastRedisLocalCache(Long 秒) 如@FastRedisLocalCache(60L) 缓存60秒
 * FastRedisLocalCache(cacheTime = 时间,cacheTimeType = TimeUnit) 如@FastRedisLocalCache(cacheTime =1L,cacheTimeType = TimeUnit.HOURS) 缓存1小时
 */
2: @FastRedisLocalCache

/**
 * 纯本地内存缓存,当集群项目部署,不会进行其他服务器的缓存刷新,使用场景需要注意,缓存的数据一般不会变,比如项目存储在数据库中的配置信息等
 * 当开启缓存并操作对象配置此注解时,会将查询到的数据缓存到本地中
 * 当进行使用此框架模板进行操作新增,更新,删除操作时,会自动刷新内存中缓存的数据
 * 默认参数为框架设置的缓存时间和类型
 * 缓存可选参数
 * FastStatisCache(Long 秒) 如@FastStatisCache(60L) 缓存60秒
 * FastStatisCache(cacheTime = 时间,cacheTimeType = TimeUnit) 如@FastStatisCache(cacheTime =1L,cacheTimeType = TimeUnit.HOURS) 缓存1小时
 */
3: @FastStatisCache
----

==== 2.5 数据源切换
[source,text]
----
可以在任意一次执行时进行数据源更换,更换数据源只对当前线程影响,根据不同的使用实现进行切换
    1:使用SpringJdbc实现更换数据源
        SpringJDBCMySqlImpl.dataSource(getDataSource());
    2:使用MyBatis实现更换数据源
        FastMyBatisImpl.dataSource(getDataSource());

    public DataSource getDataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl("jdbc:mysql://127.0.0.1:3306/demo2");
        dataSource.setUsername("root");
        dataSource.setPassword("123456");
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        return dataSource;
    }
----





































